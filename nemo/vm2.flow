import labs/nemo/nemo;

export {
    translateToVMCode(prog: NemoAst) -> vmCode;

    vmVar(name: string, type: Type, val : Value);
    Value::= ArrVal, IntVal;
    ArrVal(val: [Value]);
    IntVal(val: int);

    vmCode(vars: [DefVar], opers: [vmOper]);
    vmOper::= AssignOper, CondOper;
    AssignOper(label: int, name: string, exp: ArithExpr, goto: [int]);
    CondOper(label: int, cond: Condition, then: [int], or: [int]);

    State(label: int, vars: Tree<string, vmVar>);
}

translateToVMCode(prog: NemoAst) -> vmCode
{
    vars = prog.def_vars;
    opers = progBodyToOpers(prog.body);
    vmCode(vars, opers);
}

progBodyToOpers(body: Body) -> [vmOper] 
{
    switch(body)
    {
        Assignment(var, expr):
        {
            [AssignOper(0, var, expr, [1])];
        }
        Test(cond):
        {
            [CondOper(0, cond, [1], [])];
        }
        Sequence(next):
        {
            fold(next, [], \ops, nt -> {
                end = operMaxLabel(ops);
                next_ops = increaseOperLabels(progBodyToOpers(nt), end);
                concat(ops, next_ops);
            });
        }
        Choice(sel):
        {
            fold(sel, [], \ops, st -> 
            {
                opers = increaseOperLabels(ops, 1);
                end_prev = operMaxLabel(opers);
                next_ops = increaseOperLabels(progBodyToOpers(st), end_prev);
                end_next = operMaxLabel(next_ops);
                concat(
                    concat(
                        [CondOper(0, Comparison(Int(1), Int(1), Equal()), [1, end_prev], [])], 
                        replaceLabel(opers, end_next, end_prev)
                    ), 
                    next_ops
                );
            });
        }
        Loop(b):
        {
            ops = increaseOperLabels(progBodyToOpers(b), 1);
            end = operMaxLabel(ops);
            concat([CondOper(0, Comparison(Int(1), Int(1), Equal()), [1, end], [])], replaceLabel(ops, 0, end));
        }
    }
}

operMaxLabel(ops: [vmOper]) -> int
{
    fold(ops, 0, \max_l, op -> {
        m = switch(op)
        {
            AssignOper(label, name, expr, goto):
            {
                max(label, fold(goto, 0, max));
            }
            CondOper(label, cond, then, or):
            {
                max(fold(then, 0, max), max(label, fold(or, 0, max)));
            }
        }
        max(max_l, m);
    });
}

increaseOperLabels(ops: [vmOper], value: int) -> [vmOper]
{
    map(ops, \op -> {
        switch (op) {
            AssignOper(label, name, expr, goto):
            {
                AssignOper(label + value, name, expr, map(goto, \l -> l + value));
            }
            CondOper(label, cond, then, or): 
            {
                CondOper(label + value, cond, map(then, \l -> l + value), map(or, \l -> l + value));
            }
        }
    });   
}

replaceLabel(ops: [vmOper], to: int, from: int) -> [vmOper]
{
    map(ops, \op -> {
        switch (op) 
        {
            AssignOper(label, name, expr, goto): 
            {
                AssignOper((if (label == from) to else label), name, expr, map(goto, \l -> (if (l == from) to else l)));
            }
            CondOper(label, cond, then, or):
            {
                CondOper((if (label == from) to else label), cond, map(then, \l ->  (if (l == from) to else l)), map(or, \l -> (if (l == from) to else l)));
            }
        }
    });
}

executeProgram(code: vmCode) -> [State]
{
    vars = fold(code.vars, makeTree(), \tree, dec -> {
        setTree(tree, dec.name, vmVar(dec.name, dec.type, switch(dec.type) {
            IntType(): IntVal(0);
            Array(typ): ArrVal([]);
        }))
    });

    executeCode(code.opers, [State(0, vars)]);
}

executeCode(opers: [vmOper], states: [State]) -> [State]
{
    exit_label = operMaxLabel(opers);

    new_states = fold(states, [], \sts, st -> {
        label = st.label;

        ops = findLabel(opers, label);
        new_sts = fold(ops, [], \n_o, op -> { 
            switch(op) 
            {
                AssignOper(lbl, name, expr, goto): 
                {
                    vars = execAssign(name, expr, st.vars);
                    fold(goto, [], \n_s, l -> {
                        arrayPush(n_s, State(l, vars));
                    });
                }
                CondOper(lbl, cond, then, or): 
                {
                    p = execCond(cond, st.vars);
                    if(p) 
                    {
                        fold(then, [], \n_s, l -> {
                            arrayPush(n_s, State(l, st.vars));
                        });
                    }
                    else 
                    {
                        fold(or, [], \n_s, l -> {
                            arrayPush(n_s, State(l, st.vars));
                        });
                    }
                }
            }
        });

        concat(sts, new_sts);
    });

     exit_states = fold(new_states, [], \es, st -> {
        if (st.label == exit_label) 
        {
            arrayPush(es, st);
        } 
        else 
        {
            es;
        }
    });

    exec_states = fold(new_states, [], \sts, st -> {
        if (contains(exit_states, st)) 
        {
            sts;
        } 
        else 
        {
            arrayPush(sts, st);
        }
    });

    if (length(exec_states) == 0) 
    {
        exit_states;
    } 
    else 
    {
        concat(exit_states, executeCode(opers, exec_states));
    }
}

findLabel(opers: [vmOper], label: int) -> [vmOper]
{
    fold(opers, [], \ops, op -> {
        if (op.label == label) 
        {
            arrayPush(ops, op);
        } 
        else 
        {
            ops;
        }
    });
}

execAssign(name: string, exp: ArithExpr, vars: Tree<string, vmVar>) -> Tree
{
    setTree(vars, name, vmVar(name, getTypeVM(exp, vars), calculate(exp, vars)));
}

getTypeVM(exp: ArithExpr, declared_vars: Tree<string, vmVar>) -> Type
{
    switch (exp) 
    {
        Var(name):
        {
            var_name = lookupTree(declared_vars, name);
            switch(var_name)
            {
                Some(n): {n.type}
                None(): 
                {
                    println("Not declared variable: " + name);
                    IntType();
                }
            }
        }
        Apply(arr, index): // returns type of array elements
        {
            type = getTypeVM(arr, declared_vars);
            switch(type)
            {
                IntType():
                {
                    println("Trying to Apply to a non-array variable");
                    IntType();
                }
                Array(typ):
                {
                    typ; 
                }
            }
        }
        Upd(arr, index, val): // returns type of the array
        {
            type = getTypeVM(arr, declared_vars);
            switch(type)
            {
                IntType():
                {
                    println("Trying to Upd a non-array variable");
                    IntType();
                }
                Array(typ):
                {
                    type;
                }
            }
        }
        default: IntType();
    }
}

execCond(condition: Condition, vars: Tree<string, vmVar>) -> bool
{
    switch(condition) 
    {
        LogicOr(left, right): 
        {
            execCond(left, vars) || execCond(right, vars);
        }
        LogicAnd(left, right): 
        {
            execCond(left, vars) && execCond(right, vars);
        }
        LogicNot(cond): 
        {
            !execCond(cond, vars);
        }
        Comparison(l, r, relation): 
        {
            left = calculate(l, vars);
            right = calculate(r, vars);

            switch(left) 
            {
                ArrVal(l_val): 
                {
                    println("There is an error in comparison. Can't compare");
                    false;
                }
                IntVal(l_val): 
                {
                    switch(right) 
                    {
                        ArrVal(r_val): 
                        {
                            println("There is an error in comparison. Can't compare");
                            false;
                        }
                        IntVal(r_val): {
                            switch(relation) 
                            {
                                Equal(): l_val == r_val;
                                NotEqual(): l_val != r_val;
                                Greater(): l_val > r_val;
                                GreaterEqual(): l_val >= r_val;
                                Less(): l_val < r_val;
                                LessEqual(): l_val <= r_val;
                            }
                        }
                    }
                }
            }

        }
    }
}

// ArithExpr ::= Add, Sub, Mul, Div, Var, Int, Apply, Upd;
calculate(exp: ArithExpr, vars: Tree<string, vmVar>) -> Value
{
    switch(exp) 
    {
        Int(value): 
        {
            IntVal(value);
        }
        Var(name): 
        {
            mVar = lookupTree(vars, name);
            switch(mVar) 
            {
                None(): 
                {
                    println(name + " variable is not defined.");
                    IntVal(0);
                }
                Some(v): v.val; // v means Vendetta  :)
            }
        }
        Apply(a, i): 
        {
            array = calculate(a, vars);
            index = calculate(i, vars);

            switch (array) 
            {
                IntVal(v): 
                {
                    println("Using invalid array. Can't acces value");
                    IntVal(0);
                }
                ArrVal(v): 
                {
                    switch(index) 
                    {
                        ArrVal(val): 
                        {
                            println("Using invalid array. Can't acces value");
                            IntVal(0);
                        }
                        IntVal(val): 
                        {
                            array.val[index.val];
                        }
                    }
                }
            }
        }
        Upd(a, i, v): 
        {
            array = calculate(a, vars);
            index = calculate(i, vars);
            value = calculate(v, vars);

            switch (array) 
            {
                IntVal(val): 
                {
                    println("Using invalid array. Can't update");
                    IntVal(0);
                }
                ArrVal(val): 
                {
                    switch(index) 
                    {
                        ArrVal(arr_v): 
                        {
                            println("Using invalid array. Can't update");
                            IntVal(0);
                        }
                        IntVal(int_v): 
                        {
                            if (length(array.val) < index.val) 
                            {
                                arr = arrayResize(array.val, index.val + 1, IntVal(0));
                                ArrVal(replace(arr, index.val, value));
                            } 
                            else 
                            {
                                ArrVal(replace(array.val, index.val, value));
                            }
                        }
                    }
                }
            }
            
        }
        Add(l, r):
        {
            left = calculate(l, vars);
            right = calculate(r, vars);

            switch(left)
            {
                ArrVal(l_val): 
                {
                    println("Can't use arithmetics. There is an error");
                    IntVal(0);
                }
                IntVal(l_val):
                {
                     switch(right) 
                     {
                        ArrVal(r_val): 
                        {
                            println("Can't use arithmetics. There is an error");
                            IntVal(0);
                        }
                        IntVal(r_val): 
                        {
                            IntVal(l_val + r_val);
                        }
                     }
                }
            }
        }
        Mul(l, r):
        {
            left = calculate(l, vars);
            right = calculate(r, vars);

            switch(left)
            {
                ArrVal(l_val): 
                {
                    println("Can't use arithmetics. There is an error");
                    IntVal(0);
                }
                IntVal(l_val):
                {
                     switch(right) 
                     {
                        ArrVal(r_val): 
                        {
                            println("Can't use arithmetics. There is an error");
                            IntVal(0);
                        }
                        IntVal(r_val): 
                        {
                            IntVal(l_val * r_val);
                        }
                     }
                }
            }
        }
        Div(l, r):
        {
            left = calculate(l, vars);
            right = calculate(r, vars);

            switch(left)
            {
                ArrVal(l_val): 
                {
                    println("Can't use arithmetics. There is an error");
                    IntVal(0);
                }
                IntVal(l_val):
                {
                     switch(right) 
                     {
                        ArrVal(r_val): 
                        {
                            println("Can't use arithmetics. There is an error");
                            IntVal(0);
                        }
                        IntVal(r_val): 
                        {
                            IntVal(l_val / r_val);
                        }
                     }
                }
            }
        }
        Sub(l, r): {
            left = calculate(l, vars);
            right = calculate(r, vars);

            switch(left)
            {
                ArrVal(l_val): 
                {
                    println("Can't use arithmetics. There is an error");
                    IntVal(0);
                }
                IntVal(l_val):
                {
                     switch(right) 
                     {
                        ArrVal(r_val): 
                        {
                            println("Can't use arithmetics. There is an error");
                            IntVal(0);
                        }
                        IntVal(r_val): 
                        {
                            IntVal(l_val - r_val);
                        }
                     }
                }
            }
        }
    }
}
