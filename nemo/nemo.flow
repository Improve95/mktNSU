import string;
import ds/array;
import ds/tree;
import ds/set;
import lingo/pegcode/driver;

export {
    Exp ::= Add, Sub, Mul, Div, Var, Int, APP, UPD;
    Sub(left: Exp, right: Exp);
    Add(left: Exp, right: Exp); 
    Mul(left: Exp, right: Exp);
    Div(left: Exp, right: Exp);
    Neg(exp: Exp);
    Var(letter: string);
    Int(num: int);

    Program(def_vars: [DefVar], body: Body);
    Body::= Assignment, Test, Iter, Next, Select;
    Next(next: [Body]);
    Select(sel : [Body]); 
    Assignment(var: string, exp: Exp);
    DefVar(name: string, type: Type);
    Test(be: Condition);
    Iter(b: Body);
    APP(var: Var, index: Int);
    UPD(var: Var, index: Int, val: Exp);

    Type::= INT, Array;
    INT();
    Array(type: Type);

    Condition::= LogicAnd, LogicOr, LogicNot, Comparison;
    LogicOr(left: Condition, right: Condition);
    LogicAnd(left: Condition, right: Condition);
    LogicNot(cond: Condition);

    Comparison(left: Exp, right: Exp, relation: Relation);
    Relation::= Equal, NotEqual, Greater, Less, GreaterEqual, LessEqual;
    Equal();
    NotEqual();
    Greater();
    GreaterEqual();
    Less();
    LessEqual();

    parse(text : string) -> Program;
}

grammar = compilePegGrammar("#include nemo.lingo");

buildSub(xs : [flow])
{
    fold(xs[1], xs[0], \acc, x -> Sub(acc, x));
}

buildAdd(xs : [flow])
{
    fold(xs[1], xs[0], \acc, x -> Add(acc, x));
}

buildMul(xs : [flow])
{
    fold(xs[1], xs[0], \acc, x -> Mul(acc, x));
}

buildDiv(xs : [flow])
{
    fold(xs[1], xs[0], \acc, x -> Mul(acc, x));
}

buildSelect(xs : [flow])
{
    Select(insertArray(xs[1], 0, xs[0]));
}

specialPegActions = {
    f = setTree(defaultPegActions.t, "buildSelect", buildSelect);

	s = setTree(f, "buildSub", buildSub);

    a = setTree(s, "buildAdd", buildAdd);

    m = setTree(a, "buildMul", buildMul);

    d = setTree(m, "buildDiv", buildDiv);

	SemanticActions(d);
}

parse(text : string) -> Program {
    parsic(grammar, text, specialPegActions);
}
