import nemo;

export {
    checkProgram(prog: Program) -> bool;
}

checkProgram(prog: Program) -> bool
{
    decl = checkDecl(prog.def_vars);
    switch(decl)
    {
        None(): false;
        Some(dec):
        {
            checkBody(prog.body, dec);
        }
    }
}

checkDecl(defs: [DefVar]) -> Maybe<Tree>
{
    fold(defs, Some(makeTree()), \vars, def -> {
        switch (vars) 
        {
            None() : None();
            Some(tree): 
            { 
                var = lookupTree(tree, def.name);
                switch(var)
                {
                    None():
                    {
                        maybeMap(vars, \t -> setTree(t, def.name, def.type));   
                    }
                    Some(v):
                    {
                        println("Do not redeclare: " + def.name);
                        None();
                    }
                }
            }
        }
    }); 
}

checkBody(body: Body, declared_vars: Tree<string, Type>) -> bool
{
    println(body);
    println("");
    switch(body)
    {
        Assignment(var, ex):
        {
            mvar = lookupTree(declared_vars, var);
            switch (mvar) 
            {
                None(): 
                {
                    println("Assigning to the not declared veriable");
                    false;
                }
                Some(v):
                {
                    checkExpression(ex, declared_vars); // + check types
                }
            }
        }
        Test(be):
        {
            checkCond(be, declared_vars);
        }
        Iter(b):
        {
            checkBody(b, declared_vars);
        }
        Next(b):
        {
            fold(b, true, \correct, next -> {
                correct && checkBody(next, declared_vars);
            });
        }
        Select(s):
        {
            fold(s, true, \correct, st -> {
                correct && checkBody(st, declared_vars);
            });
        }
    }
}

//Exp ::= Add, Sub, Mul, Div, Var, Int, APP, UPD;
checkExpression(exp: Exp, declared_vars: Tree<string, Type>) -> bool
{
    switch(exp)
    {
        APP(arr, index):
        {
            // index can be an expression :)
            firstCheck = checkExpression(arr, declared_vars) && checkExpression(index, declared_vars);

            secondCheck = isArrayType(getType(arr, declared_vars));
            if(!secondCheck)
            {
                println("Using not valid array in APP");
            } 

            thirdCheck = areTypesEqual(getType(index, declared_vars), INT());
            if(!thirdCheck)
            {
                println("Using not valid index in APP");
            }

            firstCheck && secondCheck && thirdCheck;
        }
        UPD(arr, index, val):
        {
            firstCheck = checkExpression(arr, declared_vars) && checkExpression(index, declared_vars) && checkExpression(val, declared_vars);

            secondCheck = getType(arr, declared_vars);
            correctnes = switch(secondCheck)
            {
                INT():
                {
                    println("Using not valid array in UPD");
                    false;
                }
                Array(t):
                {
                    value = areTypesEqual(t, getType(val, declared_vars));
                    if(value)
                    {
                        true;
                    }
                    else
                    {
                        println("Value type do not match array type in UPD");
                        false;
                    }
                }
            }

            thirdCheck = areTypesEqual(getType(index, declared_vars), INT());
            if(!thirdCheck)
            {
                println("Using not valid index in APP");
            }

            firstCheck && correctnes && thirdCheck;
        }
        Var(name):
        {
            var = lookupTree(declared_vars, name);
            switch(var)
            {
                Some(v):
                {
                    true;
                }
                None():
                {
                    println("Variable: " + name + "not declared");
                    false;
                }
            }
        }
        Add(left, right):
        {
            firstCheck = checkExpression(left, declared_vars) && checkExpression(right, declared_vars);

            leftInt = areTypesEqual(getType(left, declared_vars), INT());
            if(!leftInt)
            {
                println("Left value of addition is not correct");
            }

            rightInt = areTypesEqual(getType(right, declared_vars), INT());
            if(!rightInt)
            {
                println("Right value of addition is not correct");
            }

            firstCheck && leftInt && rightInt;
        }
        Mul(left, right):
        {
            firstCheck = checkExpression(left, declared_vars) && checkExpression(right, declared_vars);

            leftInt = areTypesEqual(getType(left, declared_vars), INT());
            if(!leftInt)
            {
                println("Left value of mul is not correct");
            }

            rightInt = areTypesEqual(getType(right, declared_vars), INT());
            if(!rightInt)
            {
                println("Right value of mul is not correct");
            }

            firstCheck && leftInt && rightInt;
        }
        Div(left, right):
        {
            firstCheck = checkExpression(left, declared_vars) && checkExpression(right, declared_vars);

            leftInt = areTypesEqual(getType(left, declared_vars), INT());
            if(!leftInt)
            {
                println("Left value of div is not correct");
            }

            rightInt = areTypesEqual(getType(right, declared_vars), INT());
            if(!rightInt)
            {
                println("Right value of div is not correct");
            }

            firstCheck && leftInt && rightInt;
        }
        Sub(left, right):
        {  
            firstCheck = checkExpression(left, declared_vars) && checkExpression(right, declared_vars);

            leftInt = areTypesEqual(getType(left, declared_vars), INT());
            if(!leftInt)
            {
                println("Left value of sub is not correct");
            }

            rightInt = areTypesEqual(getType(right, declared_vars), INT());
            if(!rightInt)
            {
                println("Right value of sub is not correct");
            }

            firstCheck && leftInt && rightInt;
        }
        default: true;
    }
}

isArrayType(type: Type) -> bool
{
    switch (type) 
    {
        INT(): false;
        Array(a): true;
    }
}

areTypesEqual(type1: Type, type2: Type) -> bool
{
    switch(type1)
    {
        INT():
        {
            switch (type2) 
            {
                INT(): true;
                Array(a): false
            }
        }
        Array(a):
        {
            switch (type2) 
            {
                INT(): false;
                Array(b): areTypesEqual(a, b);
            }
        }
    }
}

checkCond(cond: Condition, declared_vars: Tree<string, Type>) -> bool
{
    switch(cond)
    {
        LogicAnd(left, right):
        {
            checkCond(left, declared_vars) && checkCond(right, declared_vars);
        }
        LogicOr(left, right):
        {
            checkCond(left, declared_vars) && checkCond(right, declared_vars);
        }
        LogicNot(a):
        {
            checkCond(a, declared_vars);
        }
        Comparison(left, right, relation):
        {
            firstCheck = checkExpression(left, declared_vars) && checkExpression(right, declared_vars);

            l = areTypesEqual(getType(left, declared_vars), INT());
            if(!l)
            {
                println("There is an mistake in comparison");
            }

            r = areTypesEqual(getType(right, declared_vars), INT());
            if(!r)
            {
                println("There is an mistake in comparison");
            }

            firstCheck && l && r;
        }
    }
}

getType(exp: Exp, declared_vars: Tree<string, Type>) -> Type
{
    switch (exp) 
    {
        Var(name):
        {
            var_name = lookupTree(declared_vars, name);
            switch(var_name)
            {
                Some(n): {n}
                None(): 
                {
                    println("Not declared variable: " + name);
                    INT();
                }
            }
        }
        APP(arr, index): // returns type of array elements
        {
            type = getType(arr, declared_vars);
            switch(type)
            {
                INT():
                {
                    println("Trying to APP to a non-array variable");
                    INT();
                }
                Array(typ):
                {
                    typ; 
                }
            }
        }
        UPD(arr, index, val): // returns type of the array
        {
            type = getType(arr, declared_vars);
            switch(type)
            {
                INT():
                {
                    println("Trying to UPD a non-array variable");
                    INT();
                }
                Array(typ):
                {
                    type;
                }
            }
        }
        default: INT();
    }
}