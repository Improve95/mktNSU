import exprDecl;

/* 
	s2ie - string to infix expression
  	re2ie - rpn expression to infix expression
	ie2s - infix expression to string
  	calIe - calculate infix expression
*/

export {
	s2ie(s : string) -> [InfixExpr];
  	re2ie(e : [RpnExpr]) -> InfixExpr;
  	ie2s(e : InfixExpr, priority : int) -> string;
  	calcIe(e : InfixExpr) -> double;
}

arithGrammarOp : ref Maybe<[PegOp]> = ref None();

arithGrammar() {
    onlyOnce(arithGrammarOp, \ -> {
        compilePegGrammar("#include infix.lingo");
    });
}

buildOp(xs : [flow]) {
	fold(xs[2], xs[1], \acc, x -> BinOp(xs[0], acc, x));
}

s2ie(s : string) -> [InfixExpr] {
	specialPegActions = {
		t1 = setTree(defaultPegActions.t, "buildOp", buildOp);
		SemanticActions(t1);
	}
	parsic(arithGrammar(), s, specialPegActions);
}

re2ie(e : [RpnExpr]) -> InfixExpr {
  	stack : [InfixExpr] = [];
	a = fold(e, stack, \st, val -> {
		switch (val) {
			Const(c):
				arrayPush(st, Const(c));
			OpName(name): {
				right = lastElement(st, Const(0.0));
				a = removeIndex(st, length(st) - 1);
				left = lastElement(a, Const(0.0));
				b = removeIndex(a, length(a) - 1);
				arrayPush(b, BinOp(name, left, right));
			}
		}
	});
	a[0];
}

ie2s(e : InfixExpr, priority : int) -> string {
	switch (e) {
		Const(number) : d2s(number);
		BinOp(name, l, r) : {
			if (name == "+") {
				retStr = ie2s(l, 2) + "+" + ie2s(r, 2);
				if (priority > 1) {
					"(" + retStr + ")";
				} else {
					retStr;
				}
			} else if (name == "*") {
				retStr = ie2s(l, 2) + "*" + ie2s(r, 2);
				if (priority > 1) {
					"(" + retStr + ")";
				} else {
					retStr;
				}
			} else {
				"empty";
			}
		}
	}
}

calcIe(e : InfixExpr) -> double {
	switch (e) {
		Const(number) : number;
		BinOp(name, l, r) : {
			if (name == "+") {
				calcIe(l) + calcIe(r);
			} else if (name == "*") {
				calcIe(l) * calcIe(r);
			} else {
				0.0;
			}
		} 
	}
}