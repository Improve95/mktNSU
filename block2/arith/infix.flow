import labs/block2/arith/exprDecl;

/* 
	s2ie - string to infix expression
	ie2s - infix expression to string
	calcIe - calculate infix expression
 */

export {
	s2ie(s : string) -> InfixExpr;
  	ie2s(e : InfixExpr, priority : int) -> string;
  	calcIe(e : InfixExpr, vars : Tree<string, double>) -> double;
}

buildOp(xs : [flow]) {
	fold(xs[2], xs[1], \acc, x -> BinOp(xs[0], acc, x));
}

s2ie(s : string) -> InfixExpr {
	specialPegActions = {
		t1 = setTree(defaultPegActions.t, "buildOp", buildOp);
		SemanticActions(t1);
	}
	parsic(infixGrammar, s, specialPegActions);
}

ie2s(e : InfixExpr, priority : int) -> string {
	switch (e) {
		Const(number) : d2s(number);

		Var(name) : name;

		Frac(l, r) : "[" + ie2s(l, 0) + "|" + ie2s(r, 0) + "]";

		Unary(binOp) : ie2s(binOp, -1);

		Log(ex) : "log(" + ie2s(ex, 0) + ")";

		BinOp(name, l, r) : {
			if (name == "+") {
				retStr = ie2s(l, 1) + "+" + ie2s(r, 1);
				if (priority > 1) {
					"(" + retStr + ")";
				} else {
					retStr;
				}
			} else if (name == "-") {
				retStr = ie2s(l, 1) + "-" + ie2s(r, 1);
				if (priority > 1) {
					"(" + retStr + ")";
				} else {
					retStr;
				}
			} else if (name == "*") {
				retStr = ie2s(l, 2) + "*" + ie2s(r, 2);
				if (priority == -1) {
					"(-" + ie2s(l, 2) + ")";
				} else if (priority >= 2) {
					"(" + retStr + ")";
				} else {
					retStr;
				}
			} else if (name == "/") {
				retStr = ie2s(l, 2) + "/" + ie2s(r, 2);
				if (priority >= 2) {
					"(" + retStr + ")";
				} else {
					retStr;
				}
			} else if (name == "^") {
				ie2s(l, 2) + "^" + ie2s(r, 2);
			} else if (name == "'") {
				"d/d" + ie2s(r, 0) + "(" + ie2s(l, 0) + ")";	
			} else {
				"empty";
			}
		}
		Null() : d2s(0.0);
	}
}

containsVar(e: InfixExpr, difVar : InfixExpr) -> bool {
	switch (e) {
		BinOp(name, l, r): containsVar(l, difVar) || containsVar(r, difVar);

		default:
			if (e == difVar) {
				true;
			} else {
				false;
			}
	}
}

takeDerivative(e : InfixExpr, difVar : InfixExpr) -> InfixExpr {
	switch (e) {
		BinOp(name, l, r) : {
			if (name == "+") {
				BinOp("+", takeDerivative(l, difVar), takeDerivative(r, difVar));
			} else if (name == "-") {
				BinOp("-", takeDerivative(l, difVar), takeDerivative(r, difVar));
			} else if (name == "*") {
				BinOp("+", BinOp("*", takeDerivative(l, difVar), r), BinOp("*", l, takeDerivative(r, difVar)));
			} else if (name == "/") {
				BinOp("/", 
					BinOp("-", BinOp("*", takeDerivative(l, difVar), r), BinOp("*", l, takeDerivative(r, difVar))), 
					BinOp("^", r, Const(2.0)));
			} else if (name == "^") {
				if (containsVar(l, difVar)) {
					if (!containsVar(r, difVar)) {
						BinOp("*", BinOp("*", r, BinOp("^", l, BinOp("-", r, Const(1.0)))), takeDerivative(l, difVar));
					} else {
						Null();
					}
				} else {
					BinOp("*", BinOp("*", BinOp("^", l, r), Log(l)), takeDerivative(r, difVar));
				}
			} else {
				takeDerivative(takeDerivative(l, r), r);
			};
		}

		Log(ex): BinOp("*", BinOp("/", Const(1.0), ex), takeDerivative(ex, difVar));
		
		default: {
			if (e == difVar) {
				Const(1.0);
			} else {
				Const(0.0);
			}
		}
	}
}

calcIe(e : InfixExpr, vars : Tree<string, double>) -> double {
	switch (e) {
		Const(number) : number;

		Var(name) : {
			switch (lookupTree(vars, name)) {
				Some(number): number;
				None(): 0.0;
			}
		}

		Frac(l, r) : calcIe(l, vars) / calcIe(r, vars);

		Unary(binOp) : calcIe(binOp, vars);

		Log(ex) : log(calcIe(ex, vars));

		BinOp(name, l, r) : {
			if (name == "+") {
				calcIe(l, vars) + calcIe(r, vars);
			} else if (name == "-") {
				calcIe(l, vars) - calcIe(r, vars);
			} else if (name == "*") {
				calcIe(l, vars) * calcIe(r, vars);
			} else if (name == "/") {
				calcIe(l, vars) / calcIe(r, vars);
			} else if (name == "^") {
				dpow(calcIe(l, vars), calcIe(r, vars));
			} else if (name == "'") {
				calcIe(takeDerivative(l, r), vars);
			} else {
				0.0;
			}
		} 

		Null() : 0.0;
	}
}