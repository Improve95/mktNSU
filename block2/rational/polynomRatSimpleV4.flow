import labs/block2/rational/polynomRatV2;

export {
    maxTransform(e : RatExpr) -> RatExpr;
}

RuleExpr(from : RatExpr, to : RatExpr);

MatchResult(result : bool, context : Tree<string, RatExpr>);

matchCheck (e1 : RatExpr, e2 : RatExpr, context : Tree<string, RatExpr>) -> MatchResult {
    switch (e1) {
        Const(val1) : {
            switch (e2) {
                Const(val2) : MatchResult(val1 == val2, context);
                default : MatchResult(false, context);
            }
        }
        Sum(l1, r1) : {
            switch (e2) {
                Sum(l2, r2) : {
                    result1 = matchCheck(l1, l2, context);
                    if (result1.result == false) result1
                    else matchCheck(r1, r2, result1.context);
                }
                default : MatchResult(false, context);
            }
        }
        Mul(l1, r1) : {
            switch (e2) {
                Mul(l2, r2) : {
                    result1 = matchCheck(l1, l2, context);
                    if (result1.result == false) result1
                    else matchCheck(r1, r2, result1.context);
                }
                default : MatchResult(false, context);
            }
        }
        Sub(l1, r1) : {
            switch (e2) {
                Sub(l2, r2) : {
                    result1 = matchCheck(l1, l2, context);
                    if (result1.result == false) result1
                    else matchCheck(r1, r2, result1.context);
                }
                default : MatchResult(false, context);
            }
        }
        Div(l1, r1) : {
            switch (e2) {
                Div(l2, r2) : {
                    result1 = matchCheck(l1, l2, context);
                    if (result1.result == false) result1
                    else matchCheck(r1, r2, result1.context);
                }
                default : MatchResult(false, context);
            }
        }
        Neg(arg1) : {
            switch (e2) {
                Neg(arg2) : matchCheck(arg1, arg2, context);
                default : MatchResult(false, context);
            }
        }
        Var(name) : {
            switch(lookupTree(context, name)) {
                None() : {
                    MatchResult(true, setTree(context, name, e2));
                }
                Some(val) : {
                    MatchResult(val == e2, context);
                }
            }
        }
    }
}

transformExprWithContext(e : RatExpr, context : Tree<string, RatExpr>) -> RatExpr {
    switch(e) {
        Const(val) : e;
        Sum(l, r) : Sum(transformExprWithContext(l, context), transformExprWithContext(r, context));
        Mul(l, r) : Mul(transformExprWithContext(l, context), transformExprWithContext(r, context));
        Sub(l, r) : Sub(transformExprWithContext(l, context), transformExprWithContext(r, context));
        Div(l, r) : Div(transformExprWithContext(l, context), transformExprWithContext(r, context));
        Neg(arg) : Neg(transformExprWithContext(arg, context));
        Var(name) : {
            switch(lookupTree(context, name)) {
                None() : {
                    e;
                }
                Some(val) : {
                    val;
                }
            }
        }
    }
}

tryTransformExprByRule(e : RatExpr, t : RuleExpr) -> RatExpr {
    matchResult = matchCheck(t.from, e, makeTree());
    if (matchResult.result == false) e
    else transformExprWithContext(t.to, matchResult.context);
}

convertToRule(from : string, to : string) -> RuleExpr {
    RuleExpr(s2re(from), s2re(to));
}


transformations = [
    convertToRule("x + y", "y + x"),
    // convertToRule("x + x", "2 * x"),
    // convertToRule("x + y + z", "y + z + x"),
    convertToRule("x + 0", "x"),
    convertToRule("x * 1", "x"),
    convertToRule("x - x", "0"),
    convertToRule("0 * x", "0"), 
    convertToRule("x * a + x * b", "x * (a + b)"),
    convertToRule("x * x - y * y", "(x + y) * (x - y)")
];

transformExprByAllRules(e : RatExpr) -> RatExpr {
    e1 = fold(transformations, e, \exp, t -> {
        tryTransformExprByRule(exp, t);
    });

    switch (e1) {
        Const(val) : e1;
        Var(name) : e1;
        Sum(l, r) : Sum(transformExprByAllRules(l), transformExprByAllRules(r));
        Mul(l, r) : Mul(transformExprByAllRules(l), transformExprByAllRules(r));
        Sub(l, r) : Sub(transformExprByAllRules(l), transformExprByAllRules(r));
        Div(l, r) : Div(transformExprByAllRules(l), transformExprByAllRules(r));
        Neg(arg) : Neg(transformExprByAllRules(arg));
    }
}

maxTransform(e : RatExpr) -> RatExpr {
    newExpr = transformExprByAllRules(e);
    if (newExpr == e) e
    else maxTransform(newExpr);
}