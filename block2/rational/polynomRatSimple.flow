import labs/block2/rational/polynomRat;

export {
    simplificationByIdentity(polynom : ratPolynom, identity : Pair<string, string>)       -> ratPolynom;
    simplificationByIdentities(polynom : ratPolynom, identities : [Pair<string, string>]) -> ratPolynom;
}

simplificationByIdentities(polynom : ratPolynom, identities : [Pair<string, string>]) -> ratPolynom {
    tst = fold(identities, polynom, \acc, elem -> simplificationByIdentity(acc, elem));
    if (tst == polynom) tst
    else simplificationByIdentities(tst, identities);
}

simplificationByIdentity(polynom : ratPolynom, identity : Pair<string, string>) -> ratPolynom {
    exp1 = s2re(identity.first);
    exp2 = s2re(identity.second);
    nIdentity = Pair(exp1, exp2);
    num = polynom.numerator;
    den = polynom.denominator;
    div = Div(num, den);
    res = simplificationByIdentityRatExpr(div, nIdentity);
    if (res.structname == "Div") {
        dv = cast(res : RatExpr -> Div);
        ratPolynom(dv.l, dv.r);
    } else {
        ratPolynom(res, Const(1));
    }
}

simplificationByIdentityRatExpr(ex : RatExpr, identity : Pair<RatExpr, RatExpr>) -> RatExpr {
    pr = comparisonOfRatExpr(ex, identity.first, makeTree());
    if (pr.first) {
        simplificationByIdentityRatExpr(significationRatExpr(identity.second, pr.second), identity);
    } else switch (ex) {
            Sum(a, b) : 
                Sum(simplificationByIdentityRatExpr(a, identity), simplificationByIdentityRatExpr(b, identity));
            Mul(a, b) : 
                Mul(simplificationByIdentityRatExpr(a, identity), simplificationByIdentityRatExpr(b, identity));
            Div(a, b) : 
                Div(simplificationByIdentityRatExpr(a, identity), simplificationByIdentityRatExpr(b, identity));
            Sub(a, b) : 
                Sub(simplificationByIdentityRatExpr(a, identity), simplificationByIdentityRatExpr(b, identity));
            Neg(a) : 
                Neg(simplificationByIdentityRatExpr(a, identity));
            Const(a) : 
                Const(a);
            Var(a) : 
                Var(a);
        }
}

comparisonOfRatExpr(comparable : RatExpr, sample : RatExpr, tr : Tree<Var, RatExpr>) -> Pair<bool, Tree<Var, RatExpr>> {
    if (sample.structname == "Var") {
        vr = cast(sample : RatExpr -> Var);
        switch (lookupTree(tr, vr)) {
            Some(val) : if (comparable == val) Pair(true, tr)
                        else Pair(false, makeTree());
            None() : Pair(true, setTree(tr, vr, comparable));
        }
    }
    else if (comparable.structname != sample.structname) Pair(false, makeTree())
    else {
        switch (sample) {
            Sum(a, b) : {
                tSum1 = cast(comparable : RatExpr -> Sum);
                tSum2 = sample;
                pr1 = comparisonOfRatExpr(tSum1.l, tSum2.l, tr);
                pr2 = comparisonOfRatExpr(tSum1.r, tSum2.r, tr);
                if (pr1.first && pr2.first) {
                    nTr = comparisonOfTree(pr1.second, pr2.second);
                    if (isEmptyTree(nTr)) Pair(false, nTr)
                    else Pair(true, nTr);
                }
                else Pair(false, makeTree());
            }
            Mul(a, b) : {
                tMul1 = cast(comparable : RatExpr -> Mul);
                tMul2 = sample;
                pr1 = comparisonOfRatExpr(tMul1.l, tMul2.l, tr);
                pr2 = comparisonOfRatExpr(tMul1.r, tMul2.r, tr);
                if (pr1.first && pr2.first) {
                    nTr = comparisonOfTree(pr1.second, pr2.second);
                    if (isEmptyTree(nTr)) Pair(false, nTr)
                    else Pair(true, nTr);
                }
                else Pair(false, makeTree());
            }
            Div(a, b) : {
                tDiv1 = cast(comparable : RatExpr -> Div);
                tDiv2 = sample;
                pr1 = comparisonOfRatExpr(tDiv1.l, tDiv2.l, tr);
                pr2 = comparisonOfRatExpr(tDiv1.r, tDiv2.r, tr);
                if (pr1.first && pr2.first) {
                    nTr = comparisonOfTree(pr1.second, pr2.second);
                    if (isEmptyTree(nTr)) Pair(false, nTr)
                    else Pair(true, nTr);
                }
                else Pair(false, makeTree());
            }
            Sub(a, b) : {
                tSub1 = cast(comparable : RatExpr -> Sub);
                tSub2 = sample;
                pr1 = comparisonOfRatExpr(tSub1.l, tSub2.l, tr);
                pr2 = comparisonOfRatExpr(tSub1.r, tSub2.r, tr);
                if (pr1.first && pr2.first) {
                    nTr = comparisonOfTree(pr1.second, pr2.second);
                    if (isEmptyTree(nTr)) Pair(false, nTr)
                    else Pair(true, nTr);
                }
                else Pair(false, makeTree());
            }
            Neg(a) : {
                tNeg1 = cast(comparable : RatExpr -> Neg);
                tNeg2 = sample;
                comparisonOfRatExpr(tNeg1.RatExpr, tNeg2.RatExpr, tr);
            }
            Const(a) : {
                tInt1 = cast(comparable : RatExpr -> Const);
                tInt2 = sample;
                if (tInt1.number == tInt2.number) Pair(true, setTree(tr, Var("Integer"), Var("Integer")))
                else Pair(false, makeTree());
            }
            Var(a)    : Pair(false, makeTree());
        }
    }
}

comparisonOfTree(tr1 : Tree<Var, RatExpr>, tr2 : Tree<Var, RatExpr>) -> Tree<Var, RatExpr> {
    if (isEmptyTree(tr1) || isEmptyTree(tr2)) makeTree()
    else foldTree(tr1, tr2, \key, val, acc -> {
        switch (lookupTree(acc, key)) {
            Some(p) : if (isEmptyTree(acc)) acc
                      else if (p == val) acc
                      else makeTree();
            None()  : if (isEmptyTree(acc)) acc
                      else setTree(acc, key, val);
        }
    });
}

significationRatExpr(ex : RatExpr, tr : Tree<Var, RatExpr>) -> RatExpr{
    switch(ex) {
        Sum(a, b) : Sum(significationRatExpr(a, tr), significationRatExpr(b, tr));
        Mul(a, b) : Mul(significationRatExpr(a, tr), significationRatExpr(b, tr));
        Div(a, b) : Div(significationRatExpr(a, tr), significationRatExpr(b, tr));
        Sub(a, b) : Sub(significationRatExpr(a, tr), significationRatExpr(b, tr));
        Neg(a) : Neg(significationRatExpr(a, tr));
        Const(a) : Const(a);
        Var(a) : either(lookupTree(tr, ex), Const(0));
    }
}