import labs/block2/rational/polynomRat;

/* 
    simplifyPolynom - упрощение полинома literally
    s2rule - string to rule
 */

export {
    simplifyPolynom(expr: RatExpr, rules: [MyRule]) -> RatExpr;
    s2rule(rule1 : string, rule2 : string) -> MyRule;
}

MyRule(left: RatExpr, right: RatExpr);

/* примение функции к maybe, если хоть один будет none, то вернется none */
maybeSum = maybeMap2(\l, r -> Sum(l, r));
maybeSub = maybeMap2(\l, r -> Sub(l, r));
maybeMul = maybeMap2(\l, r -> Mul(l, r));
maybeDiv = maybeMap2(\l, r -> Div(l, r));

compare(expr: RatExpr, ruleLeft: RatExpr, replacement: Maybe<Tree>) -> Maybe<Tree> {
    switch(ruleLeft) {
        Sum(left, right): {
            switch(expr) {
                Sum(l, r): {
                    compare(r, right, compare(l, left, replacement));
                }
                default: None();
            }
        }
        Sub(left, right): {
            switch(expr) {
                Sub(l, r): {
                    compare(r, right, compare(l, left, replacement));
                }
                default: None();
            }
        }
        Mul(left, right): {
            switch(expr) {
                Mul(l, r): {
                    compare(r, right, compare(l, left, replacement));
                }
                default: None();
            }
        }
        Div(left, right): {
            switch(expr) {
                Div(l, r): {
                    compare(r, right, compare(l, left, replacement));
                }
                default: None();
            }
        }
        Neg(e): {
            switch(expr: RatExpr) {
                Neg(f): {
                    compare(f, e, replacement);
                }
                default: None();
            }
        }
        Const(num): {
            switch(expr: RatExpr) {
                Const(num1): {
                    if(num1 == num) {
                        replacement;
                    } else {
                        None();
                    }
                }
                default: None();
            }
        }
        Var(name): {
            arg = maybeBind(replacement, \e -> lookupTree(e, name));
            println(arg);
            switch(arg) {
                Some(v): {
                    if(v == expr) {
                        println("return replacement");
                        replacement;
                    } else {
                        None();
                    }
                }
                None(): {
                    println("add node in replacement");
                    maybeMap(replacement, \c -> setTree(c, name, expr));
                }
            }
        }
    }
}

applyRule(ruleRight: RatExpr, replacement: Tree) -> Maybe<RatExpr> {
    println("applyRule: rule right");
    println(ruleRight);
    switch(ruleRight) {
        Sum(left, right): {
            leftValue = applyRule(left, replacement);
            rightValue = applyRule(right, replacement);
            println("applyRule: sum");
            println(leftValue);
            println(rightValue);

            maybeSum(leftValue, rightValue);
        }
        Sub(left, right): {
            println("applyRule: sub");
            leftValue = applyRule(left, replacement);
            rightValue = applyRule(right, replacement);

            maybeSub(leftValue, rightValue);
        }
        Mul(left, right): {
            leftValue = applyRule(left, replacement);
            rightValue = applyRule(right, replacement);
            println("applyRule: mul");
            println(leftValue);
            println(rightValue);

            maybeMul(leftValue, rightValue);
        }
        Div(left, right): {
            println("applyRule: div");
            leftValue = applyRule(left, replacement);
            rightValue = applyRule(right, replacement);

            maybeDiv(leftValue, rightValue);
        }
        Neg(e): {
            println("applyRule: neg");
            val = applyRule(e, replacement);
            maybeMap(val, \c -> Neg(c));
        }
        Const(num): {
            println("applyRule: const");
            Some(Const(num));
        }
        Var(name): {
            rep = lookupTree(replacement, name);
            println("applyRule: var");
            println(rep);
            rep;
        }
    }
}

tryApplyRule(expr: RatExpr, rule: MyRule) -> Maybe<RatExpr> {
    replacements = compare(expr, rule.left, Some(makeTree()));
    println("");
    println(replacements);
    println("");
    maybeBind(replacements, \repl -> { 
        println("call"); 
        applyRule(rule.right, repl); 
    });
}

applyAllRules(expr: RatExpr, rules: [MyRule], res: Set<Maybe<RatExpr>>) -> Set<Maybe<RatExpr>> {
    initSet : Set<Maybe<RatExpr>> = makeSet1(Some(expr));

    allForms = switch(expr) {
        Sum(left, right): {
            leftSet = applyAllRules(left, rules, makeSet1(Some(left)));
            rightSet = applyAllRules(right, rules, makeSet1(Some(right)));

            mergeSets(initSet, foldSet(leftSet, makeSet(), \setLeft, leftI -> {
                mergeSets(setLeft, foldSet(rightSet, makeSet(), \setRight, rightI -> { 
                    insertSet(setRight, maybeSum(leftI, rightI));
                }));
            }));
        }

        Sub(left, right): {
            leftSet = applyAllRules(left, rules, makeSet1(Some(left)));
            rightSet = applyAllRules(right, rules, makeSet1(Some(right)));

            mergeSets(initSet, foldSet(leftSet, makeSet(), \setLeft, leftI -> {
                mergeSets(setLeft, foldSet(rightSet, makeSet(), \setRight, rightI -> {
                    insertSet(setRight, maybeSub(leftI, rightI));
                }))
            }));
        }

        Mul(left, right): {
            leftSet = applyAllRules(left, rules, makeSet1(Some(left)));
            rightSet = applyAllRules(right, rules, makeSet1(Some(right)));

            mergeSets(initSet, foldSet(leftSet, makeSet(), \setLeft, leftI -> {
                mergeSets(setLeft, foldSet(rightSet, makeSet(), \setRight, rightI -> {
                    insertSet(setRight, maybeMul(leftI, rightI));
                }))
            }));
        }

        Div(left, right): {
            leftSet = applyAllRules(left, rules, makeSet1(Some(left)));
            rightSet = applyAllRules(right, rules, makeSet1(Some(right)));

            mergeSets(initSet, foldSet(leftSet, makeSet(), \setLeft, leftI -> {
                mergeSets(setLeft, foldSet(rightSet, makeSet(), \setRight, rightI -> {
                    insertSet(setRight, maybeDiv(leftI, rightI));
                }))
            }));
        }

        Neg(e): {
            set = applyAllRules(e, rules, makeSet1(Some(e)));

            foldSet(set, makeSet(), \setI, i -> {
                insertSet(setI, maybeMap(i, \c -> Neg(c)));
            });
              
            mergeSets(initSet, set);
        }

        Const(num): initSet;
        Var(name): initSet;
    }

    appliedRules = mergeSets(allForms, foldSet(allForms, makeSet(), \setI, exprI -> {
        mergeSets(setI, fold(rules, makeSet(), \setJ, rule -> {
            switch(exprI) {
                None(): setJ;
                Some(a): insertSet(setJ, tryApplyRule(a, rule));
            }
        }));
    }));

    foldSet(differenceSets(appliedRules, res), mergeSets(res, appliedRules), \acc, e -> {
        switch (e) {
            None(): acc;
            Some(a):{
                mergeSets(acc, applyAllRules(a, rules, acc));
            }
        }
    });
}

size(expr: RatExpr) {
    switch(expr) {
        Sum(left, right): size(left) + size(right);
        Sub(left, right): size(left) + size(right);
        Mul(left, right): size(left) + size(right);
        Div(left, right): size(left) + size(right);
        Neg(e): size(e);
        Const(num): 1.1;
        Var(name): 1.2;
    }
}

simplifyPolynom(expr: RatExpr, rules: [MyRule]) -> RatExpr {
    set = applyAllRules(expr, rules, makeSet1(Some(expr)));
    
    foldSet(set, expr, \exprI, i -> {
        switch(i) {
            None(): exprI;
            Some(a): {
                if(size(a) > size(exprI)) {
                    exprI;
                } else {
                    a;
                }
            }
        }
    });
}

s2rule(rule1 : string, rule2 : string) -> MyRule {
    MyRule(s2re(rule1), s2re(rule2));
}
