import string;
import lingo/pegcode/driver;
import ds/tree;
import math/math;

/* 
    s2re - string to rational expression
    re2s - rational expression to string
    calcRe - calculate rational
    reNum2s - rational expresion number to string
 */

export {
    RatExpr ::= Sum, Mul, Sub, Div, Const, Var, Neg;
        Sum : (l : RatExpr, r : RatExpr);
        Mul : (l : RatExpr, r : RatExpr);
        Sub : (l : RatExpr, r : RatExpr);
        Div : (l : RatExpr, r : RatExpr);
        Var : (var : string);
        Const : (number : int);
        Neg : (RatExpr : RatExpr);

    ratNum : (n : int, d : int);

    reNum2s(rat : Maybe<ratNum>) -> string;
    s2re(str : string) -> RatExpr;
    re2s(v : RatExpr, priority : int) -> string;
    calcRe(v : RatExpr, params : Tree<string, ratNum>) -> Maybe<ratNum>;
}

sumRatNum(l : Maybe<ratNum>, r : Maybe<ratNum>) -> Maybe<ratNum> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratNum(0,0));
        newR = either(r, ratNum(0,0));

        nok = lcm(newL.d, newR.d);
        newNumerator = nok / newL.d * newL.n + nok / newR.d * newR.n;
        newDenominator = nok;

        nod = iabs(gcd(newNumerator, newDenominator));
        Some(ratNum(newNumerator / nod, newDenominator / nod));
    } else {
        None();
    }
}

subRatNum(l : Maybe<ratNum>, r : Maybe<ratNum>) -> Maybe<ratNum> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratNum(0,0));
        newR = either(r, ratNum(0,0));

        nok = lcm(newL.d, newR.d);
        newNumerator = nok / newL.d * newL.n - nok / newR.d * newR.n;
        newDenominator = nok;

        nod = iabs(gcd(newNumerator, newDenominator));
        Some(ratNum(newNumerator / nod, newDenominator / nod));
    } else {
        None();
    }
}

mulRatNum(l : Maybe<ratNum>, r : Maybe<ratNum>) -> Maybe<ratNum> { // A/B * C/D
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratNum(0,0));
        newR = either(r, ratNum(0,0));

        nodAD = iabs(gcd(newL.n, newR.d));
        nodBC = iabs(gcd(newL.d, newR.n));
        newNumerator = newL.n / nodAD * newR.n / nodBC;
        newDenominator = newL.d / nodBC * newR.d / nodAD;

        nod = iabs(gcd(newNumerator, newDenominator));
        Some(ratNum(newNumerator / nod, newDenominator / nod));
    } else {
        None();
    }
}

divRatNum(l : Maybe<ratNum>, r : Maybe<ratNum>) -> Maybe<ratNum> { // A/B / C/D
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratNum(0,0));
        newR = either(r, ratNum(0,0));

        nodAC = iabs(gcd(newL.n, newR.n));
        nodBD = iabs(gcd(newL.d, newR.d));
        newNumerator = newL.n / nodAC * newR.d / nodBD;
        newDenominator = newL.d / nodBD * newR.n / nodAC;

        if (newDenominator == 0) {
            println("Division by zero...");
            None();
        } else {
            nod = iabs(gcd(newNumerator, newDenominator));
            Some(ratNum(newNumerator / nod, newDenominator / nod));
        }
    } else {
        None();
    }
}

reNum2s(rat : Maybe<ratNum>) -> string {
    if (isSome(rat)) {
        newRat = either(rat, ratNum(0,0));
        if (newRat.d == 0) "Division by zero..."
        else if (newRat.d == 1) i2s(newRat.n)
        else i2s(newRat.n) + "/" + i2s(newRat.d);
    } else {
        "Calculate error...";
    }
}

buildSub(xs : [flow]) {
	fold(xs[1], xs[0], \acc, x -> Sub(acc, x));
}
buildDiv(xs : [flow]) {
	fold(xs[1], xs[0], \acc, x -> Div(acc, x));
}

s2re(str : string) -> RatExpr {
    grammar = "#include labs/block2/rational/rational.lingo";
    parsic(compilePegGrammar(grammar), str, pegActions(
        [
            Pair("buildSub", buildSub),
            Pair("buildDiv", buildDiv)
        ]
    ));
}

re2s(v : RatExpr, priority : int) -> string {
    switch (v) {
        Var(a) : a;

        Const(a) : i2s(a);

        Neg(a) : "-" + re2s(a, 0);

		Sum(a, b) : {
            retStr = re2s(a, 1) + "+" + re2s(b, 1);
            if (priority > 1) {
                "(" + retStr + ")";
            } else {
                retStr
            }
        }
        Sub(a, b) : {
            retStr = re2s(a, 1) + "-" + re2s(b, 1);
            if (priority > 1) {
                "(" + retStr + ")";
            } else {
                retStr
            }
        }
		Mul(a, b) : {
            retStr = re2s(a, 2) + "*" + re2s(b, 2);
            if (priority > 2) {
                "(" + retStr + ")";
            } else {
                retStr
            }
        }
        Div(a, b) : {
            retStr = re2s(a, 2) + "/" + re2s(b, 2);
            if (priority > 2) {
                "(" + retStr + ")";
            } else {
                retStr
            }
        }
	}
}

calcRe(v : RatExpr, params : Tree<string, ratNum>) -> Maybe<ratNum> {
    switch (v) {
        Sum(a, b) : sumRatNum(calcRe(a, params), calcRe(b, params));
        Mul(a, b) : mulRatNum(calcRe(a, params), calcRe(b, params));
        Div(a, b) : divRatNum(calcRe(a, params), calcRe(b, params));
        Sub(a, b) : subRatNum(calcRe(a, params), calcRe(b, params));
        Neg(a)    : mulRatNum(Some(ratNum(-1, 1)), calcRe(a, params)); 
        Const(a)  : Some(ratNum(a, 1));
        Var(a)    : lookupTree(params, a);
    }
}
